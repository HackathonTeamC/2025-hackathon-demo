# ã‚¿ã‚¹ã‚¯6: è©±é¡Œç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³

## æ¦‚è¦
è©±é¡Œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½œæˆã¨ç®¡ç†ã€ãƒ©ãƒ³ãƒ€ãƒ é¸æŠãƒ­ã‚¸ãƒƒã‚¯ã®æœ€é©åŒ–ã‚’è¡Œã„ã¾ã™ã€‚

## ç›®çš„
- é›‘è«‡ãƒ»æŠ€è¡“çš„ãªè©±é¡Œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½œæˆ
- è©±é¡Œã®åŠ¹æœæ¸¬å®š
- å‹•çš„ãªé‡ã¿ä»˜ã‘ã«ã‚ˆã‚‹æœ€é©é¸æŠ

## å®Ÿè£…å†…å®¹

### 1. è©±é¡Œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ

#### 1.1 topics_data.jsonï¼ˆsrc/data/topics_data.jsonï¼‰

```json
[
  {
    "topic_id": "casual-lunch",
    "category": "casual",
    "content": "â˜• ä»Šæ—¥ã®ãƒ©ãƒ³ãƒã¯ä½•ã‚’é£Ÿã¹ã¾ã—ãŸã‹ï¼ŸãŠã™ã™ã‚ãŒã‚ã‚Œã°ã‚·ã‚§ã‚¢ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "ğŸ‘"
  },
  {
    "topic_id": "casual-hobby",
    "category": "casual",
    "content": "ğŸ® æœ€è¿‘ãƒãƒã£ã¦ã„ã‚‹ã‚²ãƒ¼ãƒ ã‚„è¶£å‘³ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ\nèªã‚ŠãŸã„æ–¹ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "ğŸ‰"
  },
  {
    "topic_id": "casual-book",
    "category": "casual",
    "content": "ğŸ“š æœ€è¿‘èª­ã‚“ã æœ¬ã‚„æ¼«ç”»ã§é¢ç™½ã‹ã£ãŸã‚‚ã®ã‚’æ•™ãˆã¦ãã ã•ã„ï¼\nãŠã™ã™ã‚ã—ãŸã„æ–¹ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "ğŸ“–"
  },
  {
    "topic_id": "casual-music",
    "category": "casual",
    "content": "ğŸµ ä½œæ¥­ä¸­ã«èãéŸ³æ¥½ã®ã‚¸ãƒ£ãƒ³ãƒ«ã¯ï¼Ÿé›†ä¸­ã§ãã‚‹BGMã‚’å…±æœ‰ã—ã¾ã—ã‚‡ã†ï¼",
    "reaction_emoji": "ğŸ§"
  },
  {
    "topic_id": "casual-cafe",
    "category": "casual",
    "content": "â˜• ãŠæ°—ã«å…¥ã‚Šã®ã‚«ãƒ•ã‚§ã‚„ã‚³ãƒ¼ãƒ’ãƒ¼ã‚·ãƒ§ãƒƒãƒ—ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ\nã‚·ã‚§ã‚¢ã—ãŸã„æ–¹ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "â¤ï¸"
  },
  {
    "topic_id": "casual-weekend",
    "category": "casual",
    "content": "ğŸŒŸ é€±æœ«ã®äºˆå®šã‚„æ¥½ã—ã¿ã«ã—ã¦ã„ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
    "reaction_emoji": "âœ¨"
  },
  {
    "topic_id": "tech-tools",
    "category": "technical",
    "content": "ğŸ’» æœ€è¿‘ä½¿ã£ã¦ã¿ã¦è‰¯ã‹ã£ãŸé–‹ç™ºãƒ„ãƒ¼ãƒ«ã‚„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ\nå…±æœ‰ã—ãŸã„æ–¹ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "ğŸš€"
  },
  {
    "topic_id": "tech-code-review",
    "category": "technical",
    "content": "ğŸ”§ ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§æ°—ã‚’ã¤ã‘ã¦ã„ã‚‹ã“ã¨ã‚„ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ã‚³ãƒ„ã‚’æ•™ãˆã¦ãã ã•ã„ï¼\nèˆˆå‘³ãŒã‚ã‚‹æ–¹ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "ğŸ‘€"
  },
  {
    "topic_id": "tech-debugging",
    "category": "technical",
    "content": "ğŸ› æœ€è¿‘é­é‡ã—ãŸé¢ç™½ã„ãƒã‚°ã‚„ã€å°è±¡ã«æ®‹ã£ãŸãƒ‡ãƒãƒƒã‚°ä½“é¨“ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ\nè©±ã—ãŸã„æ–¹ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "ğŸ"
  },
  {
    "topic_id": "tech-performance",
    "category": "technical",
    "content": "ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ã‚„ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã§æˆåŠŸã—ãŸäº‹ä¾‹ã‚’èã‹ã›ã¦ãã ã•ã„ï¼\nèˆˆå‘³ãŒã‚ã‚‹æ–¹ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "âš¡"
  },
  {
    "topic_id": "tech-learning",
    "category": "technical",
    "content": "ğŸ“ æ¬¡ã«å­¦ã³ãŸã„æŠ€è¡“ã‚„ã€ãƒãƒ¼ãƒ ã§å‹‰å¼·ä¼šã‚’ã‚„ã‚ŠãŸã„ãƒ†ãƒ¼ãƒã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ\nèˆˆå‘³ãŒã‚ã‚‹æ–¹ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ï¼",
    "reaction_emoji": "ğŸ“š"
  },
  {
    "topic_id": "tech-architecture",
    "category": "technical",
    "content": "ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚„ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å‚è€ƒã«ãªã£ãŸäº‹ä¾‹ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
    "reaction_emoji": "ğŸ¯"
  },
  {
    "topic_id": "tech-testing",
    "category": "technical",
    "content": "ğŸ§ª ãƒ†ã‚¹ãƒˆã®æ›¸ãæ–¹ã‚„ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã§å·¥å¤«ã—ã¦ã„ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
    "reaction_emoji": "âœ…"
  },
  {
    "topic_id": "tech-ci-cd",
    "category": "technical",
    "content": "ğŸ”„ CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ä¾¿åˆ©ãªè¨­å®šã‚„ã€è‡ªå‹•åŒ–ã—ã¦ã„ã‚‹ä½œæ¥­ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
    "reaction_emoji": "ğŸ¤–"
  }
]
```

#### 1.2 ãƒ‡ãƒ¼ã‚¿æŠ•å…¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆscripts/seed_topics.pyï¼‰

```python
import boto3
import json
from datetime import datetime
import uuid

def seed_topics(table_name: str, data_file: str):
    """è©±é¡Œãƒ‡ãƒ¼ã‚¿ã‚’DynamoDBã«æŠ•å…¥
    
    Args:
        table_name: ãƒ†ãƒ¼ãƒ–ãƒ«å
        data_file: JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
    """
    dynamodb = boto3.resource('dynamodb', region_name='ap-northeast-1')
    table = dynamodb.Table(table_name)
    
    with open(data_file, 'r', encoding='utf-8') as f:
        topics = json.load(f)
    
    now = datetime.now().isoformat()
    initial_date = '2025-01-01T00:00:00Z'
    
    for topic in topics:
        item = {
            'topic_id': topic['topic_id'],
            'category': topic['category'],
            'content': topic['content'],
            'reaction_emoji': topic['reaction_emoji'],
            'last_used_at': initial_date,
            'usage_count': 0,
            'average_reactions': 0.0,
            'created_at': now,
            'updated_at': now
        }
        
        table.put_item(Item=item)
        print(f"âœ“ Inserted: {topic['topic_id']}")
    
    print(f"\n{len(topics)} topics seeded successfully!")

if __name__ == '__main__':
    seed_topics('SlackBotTopics', '../src/data/topics_data.json')
```

### 2. è©±é¡ŒåŠ¹æœæ¸¬å®šæ©Ÿèƒ½

#### 2.1 topic_analytics.pyï¼ˆsrc/shared/topic_analytics.pyï¼‰

```python
import boto3
from boto3.dynamodb.conditions import Key
from typing import Dict, List
from datetime import datetime, timedelta

class TopicAnalytics:
    """è©±é¡Œã®åŠ¹æœæ¸¬å®šã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, topics_table: str, events_table: str):
        dynamodb = boto3.resource('dynamodb')
        self.topics_table = dynamodb.Table(topics_table)
        self.events_table = dynamodb.Table(events_table)
    
    def calculate_topic_performance(self, topic_id: str) -> Dict:
        """è©±é¡Œã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’è¨ˆç®—
        
        Args:
            topic_id: è©±é¡ŒID
        
        Returns:
            ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™
        """
        # ã“ã®è©±é¡Œã‚’ä½¿ã£ãŸã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—
        events = self._get_events_by_topic(topic_id)
        
        if not events:
            return {
                'topic_id': topic_id,
                'usage_count': 0,
                'average_reactions': 0.0,
                'meeting_creation_rate': 0.0
            }
        
        total_reactions = 0
        meetings_created = 0
        
        for event in events:
            reactions = event.get('reactions', [])
            total_reactions += len(reactions)
            
            if event.get('calendar_event_id'):
                meetings_created += 1
        
        avg_reactions = total_reactions / len(events) if events else 0
        meeting_rate = meetings_created / len(events) if events else 0
        
        return {
            'topic_id': topic_id,
            'usage_count': len(events),
            'average_reactions': round(avg_reactions, 2),
            'meeting_creation_rate': round(meeting_rate, 2),
            'total_meetings_created': meetings_created
        }
    
    def _get_events_by_topic(self, topic_id: str) -> List[Dict]:
        """è©±é¡ŒIDã§ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¤œç´¢
        
        Args:
            topic_id: è©±é¡ŒID
        
        Returns:
            ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒªã‚¹ãƒˆ
        """
        # å…¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚¹ã‚­ãƒ£ãƒ³ï¼ˆæœ€é©åŒ–ã®ä½™åœ°ã‚ã‚Šï¼‰
        response = self.events_table.scan(
            FilterExpression='topic_id = :tid',
            ExpressionAttributeValues={':tid': topic_id}
        )
        return response.get('Items', [])
    
    def update_topic_metrics(self, topic_id: str) -> None:
        """è©±é¡Œã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’æ›´æ–°
        
        Args:
            topic_id: è©±é¡ŒID
        """
        performance = self.calculate_topic_performance(topic_id)
        
        self.topics_table.update_item(
            Key={'topic_id': topic_id},
            UpdateExpression='SET average_reactions = :avg, usage_count = :count',
            ExpressionAttributeValues={
                ':avg': performance['average_reactions'],
                ':count': performance['usage_count']
            }
        )
    
    def get_best_performing_topics(self, category: str, limit: int = 5) -> List[Dict]:
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®è‰¯ã„è©±é¡Œã‚’å–å¾—
        
        Args:
            category: ã‚«ãƒ†ã‚´ãƒª
            limit: å–å¾—æ•°
        
        Returns:
            è©±é¡Œã®ãƒªã‚¹ãƒˆï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é †ï¼‰
        """
        response = self.topics_table.query(
            IndexName='CategoryIndex',
            KeyConditionExpression=Key('category').eq(category)
        )
        
        topics = response.get('Items', [])
        
        # average_reactionsã§ã‚½ãƒ¼ãƒˆ
        sorted_topics = sorted(
            topics,
            key=lambda x: x.get('average_reactions', 0),
            reverse=True
        )
        
        return sorted_topics[:limit]
```

### 3. é«˜åº¦ãªè©±é¡Œé¸æŠãƒ­ã‚¸ãƒƒã‚¯

#### 3.1 topic_selector.pyï¼ˆsrc/shared/topic_selector.pyï¼‰

```python
import random
from typing import Dict, List, Optional
from datetime import datetime, timedelta

class TopicSelector:
    """è©±é¡Œé¸æŠã®é«˜åº¦ãªãƒ­ã‚¸ãƒƒã‚¯"""
    
    def __init__(self, topics_db, analytics):
        self.topics_db = topics_db
        self.analytics = analytics
    
    def select_with_diversity(
        self,
        category: str,
        recent_days: int = 14
    ) -> Optional[Dict]:
        """å¤šæ§˜æ€§ã‚’è€ƒæ…®ã—ã¦è©±é¡Œã‚’é¸æŠ
        
        Args:
            category: ã‚«ãƒ†ã‚´ãƒª
            recent_days: é‡è¤‡ãƒã‚§ãƒƒã‚¯ã™ã‚‹æ—¥æ•°
        
        Returns:
            é¸æŠã•ã‚ŒãŸè©±é¡Œ
        """
        since = (datetime.now() - timedelta(days=recent_days)).isoformat()
        
        # æœ€è¿‘ä½¿ã£ã¦ã„ãªã„è©±é¡Œã‚’å–å¾—
        candidates = self.topics_db.get_unused_topics(category, since)
        
        if not candidates:
            # å…¨è©±é¡Œã‹ã‚‰é¸æŠï¼ˆãŸã ã—æœ€ã‚‚å¤ã„ã‚‚ã®ã‚’å„ªå…ˆï¼‰
            all_topics = self.topics_db.get_all_topics(category)
            candidates = sorted(
                all_topics,
                key=lambda x: x.get('last_used_at', '2000-01-01')
            )[:5]  # æœ€ã‚‚å¤ã„5ä»¶
        
        if not candidates:
            return None
        
        # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ™ãƒ¼ã‚¹ã®é‡ã¿ä»˜ã‘
        weights = []
        for topic in candidates:
            # average_reactions + 1 ã‚’é‡ã¿ã¨ã™ã‚‹ï¼ˆ0ã‚’é¿ã‘ã‚‹ãŸã‚+1ï¼‰
            weight = topic.get('average_reactions', 0) + 1
            # ä½¿ç”¨å›æ•°ãŒå°‘ãªã„ã‚‚ã®ã‚’å„ªå…ˆï¼ˆé€†æ•°ï¼‰
            usage_penalty = 1 / (topic.get('usage_count', 0) + 1)
            final_weight = weight * usage_penalty
            weights.append(final_weight)
        
        # é‡ã¿ä»˜ã‘ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
        selected = random.choices(candidates, weights=weights, k=1)[0]
        return selected
    
    def select_based_on_time(self) -> str:
        """æ™‚é–“å¸¯ã«åŸºã¥ã„ã¦ã‚«ãƒ†ã‚´ãƒªã‚’é¸æŠ
        
        Returns:
            ã‚«ãƒ†ã‚´ãƒªå
        """
        hour = datetime.now().hour
        
        # åˆå‰ä¸­(10:00) -> é›‘è«‡å¤šã‚
        if 9 <= hour < 12:
            return 'casual' if random.random() < 0.6 else 'technical'
        # åˆå¾Œ(15:00) -> æŠ€è¡“çš„ãªè©±é¡Œå¤šã‚
        else:
            return 'technical' if random.random() < 0.6 else 'casual'
```

## æˆæœç‰©
- [ ] è©±é¡Œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆJSONä½œæˆå®Œäº†ï¼ˆæœ€ä½20ä»¶ï¼‰
- [ ] ãƒ‡ãƒ¼ã‚¿æŠ•å…¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆä½œæˆå®Œäº†
- [ ] topic_analytics.py å®Ÿè£…å®Œäº†
- [ ] topic_selector.py å®Ÿè£…å®Œäº†
- [ ] è©±é¡Œã®åŠ¹æœæ¸¬å®šãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…å®Œäº†

## æ¤œè¨¼æ–¹æ³•

```python
# è©±é¡Œé¸æŠã®ãƒ†ã‚¹ãƒˆ
from topic_selector import TopicSelector
from database import TopicsDB
from topic_analytics import TopicAnalytics

topics_db = TopicsDB('SlackBotTopics')
analytics = TopicAnalytics('SlackBotTopics', 'SlackBotEvents')
selector = TopicSelector(topics_db, analytics)

# ã‚«ãƒ†ã‚´ãƒªã‚’æ™‚é–“ãƒ™ãƒ¼ã‚¹ã§é¸æŠ
category = selector.select_based_on_time()
print(f"Selected category: {category}")

# è©±é¡Œã‚’é¸æŠ
topic = selector.select_with_diversity(category)
print(f"Selected topic: {topic['content']}")

# ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
performance = analytics.calculate_topic_performance(topic['topic_id'])
print(f"Performance: {performance}")
```

## æ¬¡ã®ã‚¿ã‚¹ã‚¯
[ã‚¿ã‚¹ã‚¯7: ä¼šè©±å±¥æ­´åˆ†æ](./task-07-conversation-analyzer.md)

## å‚è€ƒè³‡æ–™
- [DynamoDB Query/Scanæœ€é©åŒ–](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-query-scan.html)
